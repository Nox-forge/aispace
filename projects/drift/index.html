<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Drift</title>
<style>
  * { margin: 0; padding: 0; box-sizing: border-box; }
  body { background: #000; overflow: hidden; cursor: none; }
  canvas { display: block; }

  #ui {
    position: fixed; bottom: 24px; left: 50%;
    transform: translateX(-50%);
    color: rgba(255,255,255,0.5);
    font: 13px/1.6 'SF Mono', 'Fira Code', monospace;
    text-align: center;
    transition: opacity 1.5s ease;
    pointer-events: none;
    z-index: 10;
    text-shadow: 0 0 10px rgba(0,0,0,0.8);
  }
  #ui.hidden { opacity: 0; }
  #ui .key {
    display: inline-block; padding: 1px 6px;
    border: 1px solid rgba(255,255,255,0.25);
    border-radius: 3px; margin: 0 2px;
    font-size: 11px;
  }

  #info {
    position: fixed; top: 16px; left: 20px;
    color: rgba(255,255,255,0.35);
    font: 11px/1.5 'SF Mono', 'Fira Code', monospace;
    transition: opacity 1.5s ease;
    pointer-events: none;
    z-index: 10;
  }
  #info.hidden { opacity: 0; }

  #title {
    position: fixed; top: 50%; left: 50%;
    transform: translate(-50%, -50%);
    color: rgba(255,255,255,0.6);
    font: 300 48px/1 'Helvetica Neue', Arial, sans-serif;
    letter-spacing: 16px;
    text-transform: uppercase;
    pointer-events: none;
    z-index: 10;
    animation: fadeTitle 4s ease forwards;
  }
  @keyframes fadeTitle {
    0% { opacity: 0; transform: translate(-50%, -50%) scale(0.95); }
    30% { opacity: 0.6; transform: translate(-50%, -50%) scale(1); }
    100% { opacity: 0; transform: translate(-50%, -50%) scale(1.02); }
  }
</style>
</head>
<body>
<canvas id="canvas"></canvas>
<div id="title">Drift</div>
<div id="info">
  <span id="stats"></span>
</div>
<div id="ui">
  <span class="key">1-6</span> palette
  <span class="key">M</span> mode
  <span class="key">G</span> glow
  <span class="key">C</span> connect
  <span class="key">A</span> auto
  <span class="key">Space</span> pause
  <span class="key">R</span> reset
  <span class="key">H</span> hide
  <span class="key">F</span> full
</div>

<script>
// ─── Simplex Noise ──────────────────────────────────────────────────────
// Based on Stefan Gustavson's simplex noise implementation
class SimplexNoise {
  constructor(seed = Math.random() * 65536) {
    this.grad3 = [
      [1,1,0],[-1,1,0],[1,-1,0],[-1,-1,0],
      [1,0,1],[-1,0,1],[1,0,-1],[-1,0,-1],
      [0,1,1],[0,-1,1],[0,1,-1],[0,-1,-1]
    ];
    this.perm = new Uint8Array(512);
    this.permMod12 = new Uint8Array(512);
    const p = new Uint8Array(256);
    for (let i = 0; i < 256; i++) p[i] = i;
    // Seed-based Fisher-Yates shuffle
    let s = seed;
    for (let i = 255; i > 0; i--) {
      s = (s * 16807 + 0) % 2147483647;
      const j = s % (i + 1);
      [p[i], p[j]] = [p[j], p[i]];
    }
    for (let i = 0; i < 512; i++) {
      this.perm[i] = p[i & 255];
      this.permMod12[i] = this.perm[i] % 12;
    }
  }

  noise2D(x, y) {
    const F2 = 0.5 * (Math.sqrt(3) - 1);
    const G2 = (3 - Math.sqrt(3)) / 6;
    const s = (x + y) * F2;
    const i = Math.floor(x + s);
    const j = Math.floor(y + s);
    const t = (i + j) * G2;
    const X0 = i - t, Y0 = j - t;
    const x0 = x - X0, y0 = y - Y0;
    let i1, j1;
    if (x0 > y0) { i1 = 1; j1 = 0; }
    else { i1 = 0; j1 = 1; }
    const x1 = x0 - i1 + G2, y1 = y0 - j1 + G2;
    const x2 = x0 - 1 + 2 * G2, y2 = y0 - 1 + 2 * G2;
    const ii = i & 255, jj = j & 255;
    const gi0 = this.permMod12[ii + this.perm[jj]];
    const gi1 = this.permMod12[ii + i1 + this.perm[jj + j1]];
    const gi2 = this.permMod12[ii + 1 + this.perm[jj + 1]];
    let n0 = 0, n1 = 0, n2 = 0;
    let t0 = 0.5 - x0*x0 - y0*y0;
    if (t0 >= 0) { t0 *= t0; n0 = t0 * t0 * this.dot2(this.grad3[gi0], x0, y0); }
    let t1 = 0.5 - x1*x1 - y1*y1;
    if (t1 >= 0) { t1 *= t1; n1 = t1 * t1 * this.dot2(this.grad3[gi1], x1, y1); }
    let t2 = 0.5 - x2*x2 - y2*y2;
    if (t2 >= 0) { t2 *= t2; n2 = t2 * t2 * this.dot2(this.grad3[gi2], x2, y2); }
    return 70 * (n0 + n1 + n2);
  }

  dot2(g, x, y) { return g[0]*x + g[1]*y; }

  // Fractal Brownian Motion
  fbm(x, y, octaves = 4, lacunarity = 2, gain = 0.5) {
    let sum = 0, amp = 1, freq = 1, max = 0;
    for (let i = 0; i < octaves; i++) {
      sum += this.noise2D(x * freq, y * freq) * amp;
      max += amp;
      amp *= gain;
      freq *= lacunarity;
    }
    return sum / max;
  }
}

// ─── Color Palettes ─────────────────────────────────────────────────────
const PALETTES = {
  aurora: {
    name: 'Aurora',
    bg: [4, 6, 12],
    colors: [
      [64, 224, 208], [0, 206, 209], [72, 209, 204],
      [127, 255, 212], [144, 238, 144], [152, 251, 152],
      [186, 85, 211], [147, 112, 219], [138, 43, 226]
    ]
  },
  ember: {
    name: 'Ember',
    bg: [12, 4, 2],
    colors: [
      [255, 69, 0], [255, 99, 71], [255, 140, 0],
      [255, 165, 0], [255, 200, 50], [255, 215, 0],
      [220, 20, 60], [178, 34, 34], [255, 110, 64]
    ]
  },
  ocean: {
    name: 'Ocean',
    bg: [2, 6, 16],
    colors: [
      [0, 105, 148], [0, 150, 199], [65, 182, 230],
      [100, 200, 240], [0, 180, 216], [144, 224, 239],
      [72, 202, 228], [0, 119, 182], [3, 4, 94]
    ]
  },
  ghost: {
    name: 'Ghost',
    bg: [8, 8, 12],
    colors: [
      [220, 220, 245], [200, 210, 240], [180, 190, 235],
      [240, 240, 255], [210, 220, 245], [190, 200, 240],
      [250, 250, 255], [225, 230, 250], [200, 210, 245]
    ]
  },
  neon: {
    name: 'Neon',
    bg: [4, 2, 10],
    colors: [
      [255, 0, 255], [0, 255, 255], [255, 255, 0],
      [255, 0, 128], [0, 255, 128], [128, 0, 255],
      [255, 64, 255], [64, 255, 255], [255, 128, 0]
    ]
  },
  moss: {
    name: 'Moss',
    bg: [4, 8, 4],
    colors: [
      [85, 107, 47], [107, 142, 35], [124, 152, 48],
      [143, 188, 143], [60, 120, 80], [34, 139, 34],
      [154, 205, 50], [173, 200, 96], [50, 90, 50]
    ]
  }
};

const PALETTE_KEYS = Object.keys(PALETTES);

// ─── Flow Modes ─────────────────────────────────────────────────────────
const MODES = {
  flow: {
    name: 'Flow',
    getAngle: (x, y, noise, time, scale) => {
      return noise.fbm(x * scale, y * scale + time * 0.05, 4) * Math.PI * 4;
    }
  },
  vortex: {
    name: 'Vortex',
    getAngle: (x, y, noise, time, scale, cx, cy) => {
      const dx = x - cx, dy = y - cy;
      const base = Math.atan2(dy, dx) + Math.PI * 0.5;
      const n = noise.fbm(x * scale * 0.5, y * scale * 0.5 + time * 0.03, 3);
      return base + n * 1.5;
    }
  },
  turbulence: {
    name: 'Turbulence',
    getAngle: (x, y, noise, time, scale) => {
      const n1 = noise.fbm(x * scale * 2, y * scale * 2 + time * 0.1, 6);
      const n2 = noise.fbm(y * scale * 2 + 100, x * scale * 2 + time * 0.08, 6);
      return Math.atan2(n1, n2) * Math.PI * 2;
    }
  },
  convergence: {
    name: 'Convergence',
    getAngle: (x, y, noise, time, scale, cx, cy) => {
      const dx = cx - x, dy = cy - y;
      const toCenter = Math.atan2(dy, dx);
      const n = noise.fbm(x * scale, y * scale + time * 0.04, 3);
      const dist = Math.sqrt(dx*dx + dy*dy);
      const pull = Math.min(1, dist / 400);
      return toCenter * pull + n * Math.PI * 2 * (1 - pull * 0.7);
    }
  },
  waves: {
    name: 'Waves',
    getAngle: (x, y, noise, time, scale) => {
      const wave = Math.sin(y * scale * 3 + time * 0.15) * 0.8;
      const n = noise.fbm(x * scale, y * scale + time * 0.05, 3);
      return wave + n * Math.PI * 1.5;
    }
  }
};

const MODE_KEYS = Object.keys(MODES);

// ─── Main Application ───────────────────────────────────────────────────
class Drift {
  constructor() {
    this.canvas = document.getElementById('canvas');
    this.ctx = this.canvas.getContext('2d');
    this.resize();

    this.noise = new SimplexNoise();
    this.particles = [];
    this.paused = false;
    this.time = 0;
    this.frameCount = 0;
    this.fps = 0;
    this.lastFpsTime = performance.now();
    this.fpsFrames = 0;

    // Settings
    this.particleCount = 0;
    this.targetParticles = Math.min(6000, Math.floor(this.w * this.h / 200));
    this.noiseScale = 0.002;
    this.speed = 1.5;
    this.trailAlpha = 0.04;
    this.particleAlpha = 0.7;
    this.lineWidth = 1;
    this.glow = true;
    this.connections = false;
    this.connectionDist = 50;

    // State
    this.paletteIndex = 0;
    this.palette = PALETTES[PALETTE_KEYS[0]];
    this.modeIndex = 0;
    this.mode = MODES[MODE_KEYS[0]];
    this.mouse = { x: -1000, y: -1000, active: false, radius: 150, force: 0.3 };
    this.uiVisible = true;
    this.uiTimeout = null;

    // Transition state
    this.transitioning = false;
    this.transitionStart = 0;
    this.transitionDuration = 2000;
    this.oldPalette = null;

    // Auto-evolve: slowly cycle palettes and modes
    this.autoEvolve = false;
    this.autoTimer = 0;
    this.autoInterval = 25; // seconds between changes

    this.init();
    this.bindEvents();
    this.scheduleUiHide();
    this.animate();
  }

  resize() {
    this.w = this.canvas.width = window.innerWidth;
    this.h = this.canvas.height = window.innerHeight;
    this.cx = this.w / 2;
    this.cy = this.h / 2;
  }

  init() {
    // Clear canvas to background
    const bg = this.palette.bg;
    this.ctx.fillStyle = `rgb(${bg[0]},${bg[1]},${bg[2]})`;
    this.ctx.fillRect(0, 0, this.w, this.h);

    this.particles = [];
    this.particleCount = 0;
  }

  spawnParticle() {
    const colors = this.palette.colors;
    const color = colors[Math.floor(Math.random() * colors.length)];
    return {
      x: Math.random() * this.w,
      y: Math.random() * this.h,
      vx: 0, vy: 0,
      color: color,
      alpha: 0.3 + Math.random() * 0.5,
      size: 0.5 + Math.random() * 1.5,
      life: 0,
      maxLife: 300 + Math.random() * 700,
      speed: 0.5 + Math.random() * 1.5
    };
  }

  updateParticle(p) {
    const nx = p.x / this.w;
    const ny = p.y / this.h;

    // Get flow angle from current mode
    const angle = this.mode.getAngle(
      nx, ny, this.noise, this.time,
      this.noiseScale * 500, this.cx / this.w, this.cy / this.h
    );

    // Flow force
    const flowX = Math.cos(angle) * this.speed * p.speed;
    const flowY = Math.sin(angle) * this.speed * p.speed;

    // Mouse interaction
    let mouseX = 0, mouseY = 0;
    if (this.mouse.active) {
      const dx = this.mouse.x - p.x;
      const dy = this.mouse.y - p.y;
      const dist = Math.sqrt(dx*dx + dy*dy);
      if (dist < this.mouse.radius && dist > 1) {
        const force = (1 - dist / this.mouse.radius) * this.mouse.force;
        mouseX = (dx / dist) * force * 3;
        mouseY = (dy / dist) * force * 3;
      }
    }

    // Update velocity with smooth interpolation
    p.vx += (flowX + mouseX - p.vx) * 0.1;
    p.vy += (flowY + mouseY - p.vy) * 0.1;

    // Update position
    p.x += p.vx;
    p.y += p.vy;
    p.life++;

    // Wrap around edges with margin
    const margin = 10;
    if (p.x < -margin) p.x = this.w + margin;
    if (p.x > this.w + margin) p.x = -margin;
    if (p.y < -margin) p.y = this.h + margin;
    if (p.y > this.h + margin) p.y = -margin;

    return p.life < p.maxLife;
  }

  checkTransition() {
    if (this.transitioning && this.oldPalette) {
      const elapsed = performance.now() - this.transitionStart;
      if (elapsed >= this.transitionDuration) {
        this.transitioning = false;
        this.oldPalette = null;
      }
    }
  }

  draw() {
    const ctx = this.ctx;

    this.checkTransition();

    // Trail effect: semi-transparent background overlay
    let bg = this.palette.bg;
    ctx.fillStyle = `rgba(${bg[0]},${bg[1]},${bg[2]},${this.trailAlpha})`;
    ctx.fillRect(0, 0, this.w, this.h);

    // Gradually spawn particles
    while (this.particleCount < this.targetParticles) {
      this.particles.push(this.spawnParticle());
      this.particleCount++;
      if (this.particleCount % 50 === 0) break; // Stagger spawning
    }

    // Update and draw particles
    const alive = [];
    for (let i = 0; i < this.particles.length; i++) {
      const p = this.particles[i];
      if (this.updateParticle(p)) {
        const lifeFade = p.life < 30 ? p.life / 30 :
                         p.life > p.maxLife - 50 ? (p.maxLife - p.life) / 50 : 1;
        const a = lifeFade * p.alpha * this.particleAlpha;
        const c = p.color;

        // Glow layer (larger, dimmer circle underneath)
        if (this.glow) {
          ctx.fillStyle = `rgba(${c[0]},${c[1]},${c[2]},${a * 0.15})`;
          ctx.beginPath();
          ctx.arc(p.x, p.y, p.size * 4, 0, Math.PI * 2);
          ctx.fill();
        }

        // Core particle
        ctx.fillStyle = `rgba(${c[0]},${c[1]},${c[2]},${a})`;
        ctx.beginPath();
        ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
        ctx.fill();

        alive.push(p);
      }
    }

    // Connection lines between nearby particles (when enabled)
    if (this.connections && alive.length < 4000) {
      ctx.lineWidth = 0.5;
      const dist2 = this.connectionDist * this.connectionDist;
      // Spatial grid for performance
      const cellSize = this.connectionDist;
      const grid = {};
      for (let i = 0; i < alive.length; i++) {
        const gx = Math.floor(alive[i].x / cellSize);
        const gy = Math.floor(alive[i].y / cellSize);
        const key = gx + ',' + gy;
        (grid[key] = grid[key] || []).push(i);
      }
      for (const key in grid) {
        const [gx, gy] = key.split(',').map(Number);
        const cell = grid[key];
        for (let dx = 0; dx <= 1; dx++) {
          for (let dy = -1; dy <= 1; dy++) {
            const nkey = (gx + dx) + ',' + (gy + dy);
            const ncell = grid[nkey];
            if (!ncell) continue;
            for (const i of cell) {
              for (const j of ncell) {
                if (j <= i) continue;
                const pi = alive[i], pj = alive[j];
                const ddx = pi.x - pj.x, ddy = pi.y - pj.y;
                const d2 = ddx*ddx + ddy*ddy;
                if (d2 < dist2) {
                  const strength = 1 - Math.sqrt(d2) / this.connectionDist;
                  const ca = strength * 0.15;
                  const mc = pi.color;
                  ctx.strokeStyle = `rgba(${mc[0]},${mc[1]},${mc[2]},${ca})`;
                  ctx.beginPath();
                  ctx.moveTo(pi.x, pi.y);
                  ctx.lineTo(pj.x, pj.y);
                  ctx.stroke();
                }
              }
            }
          }
        }
      }
    }

    // Replace dead particles
    while (alive.length < this.targetParticles) {
      alive.push(this.spawnParticle());
    }
    this.particles = alive;
    this.particleCount = alive.length;

    this.time += 0.016;
  }

  animate() {
    if (!this.paused) {
      this.draw();

      // Auto-evolve
      if (this.autoEvolve) {
        this.autoTimer += 1/60;
        if (this.autoTimer >= this.autoInterval) {
          this.autoTimer = 0;
          // Alternate between palette and mode changes
          if (Math.random() < 0.6) {
            this.setPalette(this.paletteIndex + 1);
          } else {
            this.setMode(this.modeIndex + 1);
          }
        }
      }
    }

    this.frameCount++;
    this.fpsFrames++;
    const now = performance.now();
    if (now - this.lastFpsTime > 1000) {
      this.fps = Math.round(this.fpsFrames * 1000 / (now - this.lastFpsTime));
      this.fpsFrames = 0;
      this.lastFpsTime = now;
      this.updateStats();
    }

    requestAnimationFrame(() => this.animate());
  }

  updateStats() {
    const stats = document.getElementById('stats');
    stats.textContent = `${this.fps} fps  |  ${this.particleCount} particles  |  ${this.mode.name}  |  ${this.palette.name}`;
  }

  setPalette(index) {
    this.oldPalette = this.palette;
    this.paletteIndex = index % PALETTE_KEYS.length;
    this.palette = PALETTES[PALETTE_KEYS[this.paletteIndex]];
    this.transitioning = true;
    this.transitionStart = performance.now();

    // Gradually recolor particles
    const colors = this.palette.colors;
    for (let i = 0; i < this.particles.length; i++) {
      if (Math.random() < 0.3) { // Only recolor 30% immediately
        this.particles[i].color = colors[Math.floor(Math.random() * colors.length)];
      } else {
        // Schedule recolor over next few seconds
        const delay = Math.random() * 120;
        const orig = this.particles[i];
        orig._recolorAt = this.frameCount + delay;
        orig._newColor = colors[Math.floor(Math.random() * colors.length)];
      }
    }
  }

  setMode(index) {
    this.modeIndex = index % MODE_KEYS.length;
    this.mode = MODES[MODE_KEYS[this.modeIndex]];
    this.updateStats();
  }

  burst(x, y, count = 100) {
    const colors = this.palette.colors;
    for (let i = 0; i < count; i++) {
      const angle = Math.random() * Math.PI * 2;
      const speed = 1 + Math.random() * 4;
      const p = this.spawnParticle();
      p.x = x;
      p.y = y;
      p.vx = Math.cos(angle) * speed;
      p.vy = Math.sin(angle) * speed;
      p.color = colors[Math.floor(Math.random() * colors.length)];
      p.maxLife = 100 + Math.random() * 200;
      this.particles.push(p);
    }
    this.particleCount = this.particles.length;
  }

  scheduleUiHide() {
    if (this.uiTimeout) clearTimeout(this.uiTimeout);
    this.uiTimeout = setTimeout(() => {
      if (this.uiVisible) {
        document.getElementById('ui').classList.add('hidden');
        document.getElementById('info').classList.add('hidden');
      }
    }, 6000);
  }

  showUi() {
    document.getElementById('ui').classList.remove('hidden');
    document.getElementById('info').classList.remove('hidden');
    this.scheduleUiHide();
  }

  bindEvents() {
    // Resize
    window.addEventListener('resize', () => {
      this.resize();
      this.targetParticles = Math.min(6000, Math.floor(this.w * this.h / 200));
    });

    // Mouse
    window.addEventListener('mousemove', (e) => {
      this.mouse.x = e.clientX;
      this.mouse.y = e.clientY;
      this.mouse.active = true;
      this.showUi();
    });

    window.addEventListener('mouseleave', () => {
      this.mouse.active = false;
    });

    window.addEventListener('click', (e) => {
      this.burst(e.clientX, e.clientY, 150);
    });

    // Touch
    window.addEventListener('touchmove', (e) => {
      e.preventDefault();
      const t = e.touches[0];
      this.mouse.x = t.clientX;
      this.mouse.y = t.clientY;
      this.mouse.active = true;
    }, { passive: false });

    window.addEventListener('touchstart', (e) => {
      const t = e.touches[0];
      this.mouse.x = t.clientX;
      this.mouse.y = t.clientY;
      this.mouse.active = true;
      this.burst(t.clientX, t.clientY, 100);
    });

    window.addEventListener('touchend', () => {
      this.mouse.active = false;
    });

    // Keyboard
    window.addEventListener('keydown', (e) => {
      this.showUi();

      switch(e.key) {
        case ' ':
          e.preventDefault();
          this.paused = !this.paused;
          break;
        case '1': case '2': case '3': case '4': case '5': case '6':
          this.setPalette(parseInt(e.key) - 1);
          break;
        case 'm': case 'M':
          this.setMode(this.modeIndex + 1);
          break;
        case 'r': case 'R':
          this.noise = new SimplexNoise();
          this.init();
          break;
        case 'h': case 'H':
          this.uiVisible = !this.uiVisible;
          if (!this.uiVisible) {
            document.getElementById('ui').classList.add('hidden');
            document.getElementById('info').classList.add('hidden');
          } else {
            this.showUi();
          }
          break;
        case 'f': case 'F':
          if (document.fullscreenElement) {
            document.exitFullscreen();
          } else {
            document.documentElement.requestFullscreen();
          }
          break;
        case 'g': case 'G':
          this.glow = !this.glow;
          break;
        case 'c': case 'C':
          this.connections = !this.connections;
          break;
        case 'a': case 'A':
          this.autoEvolve = !this.autoEvolve;
          if (!this.autoEvolve) this.autoTimer = 0;
          break;
        case 'ArrowUp':
          this.speed = Math.min(5, this.speed + 0.2);
          break;
        case 'ArrowDown':
          this.speed = Math.max(0.2, this.speed - 0.2);
          break;
        case 'ArrowRight':
          this.noiseScale = Math.min(0.01, this.noiseScale * 1.1);
          break;
        case 'ArrowLeft':
          this.noiseScale = Math.max(0.0005, this.noiseScale / 1.1);
          break;
        case '+': case '=':
          this.targetParticles = Math.min(12000, this.targetParticles + 500);
          break;
        case '-': case '_':
          this.targetParticles = Math.max(500, this.targetParticles - 500);
          break;
      }
    });

    // Mouse wheel: noise scale
    window.addEventListener('wheel', (e) => {
      e.preventDefault();
      if (e.deltaY > 0) {
        this.noiseScale = Math.min(0.01, this.noiseScale * 1.05);
      } else {
        this.noiseScale = Math.max(0.0005, this.noiseScale / 1.05);
      }
    }, { passive: false });
  }
}

// Handle deferred recoloring in the draw loop
const origDraw = Drift.prototype.draw;
Drift.prototype.draw = function() {
  // Process deferred recolors
  for (let i = 0; i < this.particles.length; i++) {
    const p = this.particles[i];
    if (p._recolorAt && this.frameCount >= p._recolorAt) {
      p.color = p._newColor;
      delete p._recolorAt;
      delete p._newColor;
    }
  }
  origDraw.call(this);
};

// Launch
window.addEventListener('DOMContentLoaded', () => {
  new Drift();
});
</script>
</body>
</html>
