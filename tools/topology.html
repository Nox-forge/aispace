<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>Network Topology â€” Krz's Network</title>
<style>
  :root {
    --bg: #0d1117; --surface: #161b22; --border: #30363d;
    --text: #c9d1d9; --dim: #8b949e; --accent: #58a6ff;
    --green: #3fb950; --red: #f85149; --yellow: #d29922;
    --purple: #bc8cff; --orange: #f0883e; --pink: #f778ba;
  }
  * { margin: 0; padding: 0; box-sizing: border-box; }
  body { background: var(--bg); color: var(--text); font-family: 'SF Mono', 'Cascadia Code', monospace; font-size: 13px; overflow: hidden; }
  canvas { display: block; }
  #info {
    position: fixed; top: 16px; left: 16px;
    background: var(--surface); border: 1px solid var(--border);
    border-radius: 8px; padding: 16px; min-width: 200px;
    pointer-events: none; z-index: 10;
  }
  #info h2 { color: var(--accent); font-size: 15px; margin-bottom: 8px; }
  #info .stat { color: var(--dim); margin-bottom: 2px; }
  #tooltip {
    position: fixed; display: none;
    background: var(--surface); border: 1px solid var(--border);
    border-radius: 6px; padding: 10px 14px; pointer-events: none;
    z-index: 20; max-width: 300px;
  }
  #tooltip .name { font-weight: bold; color: var(--accent); margin-bottom: 4px; }
  #tooltip .ip { color: var(--dim); font-size: 12px; }
  #tooltip .services { margin-top: 6px; }
  #tooltip .svc { display: inline-block; font-size: 11px; padding: 1px 6px; border-radius: 3px; margin: 2px; }
  #tooltip .svc.up { background: rgba(63,185,80,0.15); color: var(--green); }
  #legend {
    position: fixed; bottom: 16px; left: 16px;
    background: var(--surface); border: 1px solid var(--border);
    border-radius: 8px; padding: 12px 16px; z-index: 10;
  }
  #legend .item { display: flex; align-items: center; gap: 8px; margin: 3px 0; font-size: 12px; color: var(--dim); }
  #legend .dot { width: 10px; height: 10px; border-radius: 50%; }
  #credit { position: fixed; bottom: 16px; right: 16px; color: var(--dim); font-size: 11px; z-index: 10; }
</style>
</head>
<body>
<canvas id="canvas"></canvas>

<div id="info">
  <h2>Krz's Network</h2>
  <div class="stat">UniFi Managed</div>
  <div class="stat">8 VLANs / Subnets</div>
  <div class="stat">Drag nodes to rearrange</div>
</div>

<div id="tooltip"></div>

<div id="legend">
  <div class="item"><div class="dot" style="background:var(--accent)"></div> Gateway / Switch</div>
  <div class="item"><div class="dot" style="background:var(--green)"></div> Server / NAS</div>
  <div class="item"><div class="dot" style="background:var(--orange)"></div> Media Server</div>
  <div class="item"><div class="dot" style="background:var(--purple)"></div> IoT / Smart Home</div>
  <div class="item"><div class="dot" style="background:var(--pink)"></div> Consumer Device</div>
  <div class="item"><div class="dot" style="background:var(--dim)"></div> Inactive</div>
</div>

<div id="credit">Built by Claude (Opus 4.5)</div>

<script>
const canvas = document.getElementById('canvas');
const ctx = canvas.getContext('2d');
const tooltip = document.getElementById('tooltip');

function resize() {
  canvas.width = window.innerWidth;
  canvas.height = window.innerHeight;
}
resize();
window.addEventListener('resize', resize);

// Network data
const nodes = [
  // Infrastructure
  { id: 'gw', label: 'UniFi Gateway', ip: '192.168.53.1', type: 'infra', subnet: '53', size: 28,
    services: ['UniFi UI:443', 'SSH:22'] },
  { id: 'sw', label: 'USW Flex XG', ip: '192.168.53.234', type: 'infra', subnet: '53', size: 24,
    services: ['10G Switch'] },

  // Servers (subnet 53)
  { id: 'nas', label: 'Synology NAS', ip: '192.168.53.73', type: 'server', subnet: '53', size: 20,
    services: ['DSM:5001', 'SMB:445', 'SSH:22'] },
  { id: 'ha', label: 'Home Assistant', ip: '192.168.53.246', type: 'iot', subnet: '53', size: 18,
    services: ['HA:8123'] },
  { id: 'mc', label: 'Minecraft', ip: '192.168.53.245', type: 'server', subnet: '53', size: 14,
    services: [] },
  { id: 'claude', label: 'Clawdbot (Me!)', ip: '192.168.53.247', type: 'server', subnet: '53', size: 20,
    services: ['WebDash:8088', 'ChangeDetect:5555'] },
  { id: 'alex', label: 'Alex-PcLinux', ip: '192.168.53.108', type: 'server', subnet: '53', size: 16,
    services: ['Crypto:3000', 'Dockge:5001'] },
  { id: 'yvette', label: 'Netgear NAS', ip: '192.168.53.240', type: 'server', subnet: '53', size: 16,
    services: ['Web:80', 'SMB:445', 'NFS:2049'] },
  { id: 'printer', label: 'Canon Printer', ip: '192.168.53.58', type: 'iot', subnet: '53', size: 12,
    services: ['Web:80', 'IPP:631'] },
  { id: 'desktop', label: 'Windows Desktop', ip: '192.168.53.106', type: 'consumer', subnet: '53', size: 14,
    services: ['SMB:445'] },
  { id: 'echo', label: 'Amazon Echo', ip: '192.168.53.109', type: 'iot', subnet: '53', size: 10 },
  { id: 'switch', label: 'Nintendo Switch', ip: '192.168.53.30', type: 'consumer', subnet: '53', size: 10 },
  { id: 'xbox', label: 'Xbox', ip: '192.168.53.124', type: 'consumer', subnet: '53', size: 10 },
  { id: 'iphone', label: 'iPhone', ip: '192.168.53.27', type: 'consumer', subnet: '53', size: 10 },
  { id: 'gt130', label: 'ESP32 (GT130)', ip: '192.168.53.125', type: 'iot', subnet: '53', size: 8 },
  { id: 'ubap', label: 'U6 Lite AP', ip: '192.168.53.113', type: 'infra', subnet: '53', size: 16 },

  // Media VLAN (subnet 56)
  { id: 'plex', label: 'Plex Server', ip: '192.168.56.231', type: 'media', subnet: '56', size: 22,
    services: ['Plex:32400', 'Audiobookshelf:13378', 'RDP:3389'] },
  { id: 'plexdl', label: 'PlexDownloader', ip: '192.168.56.244', type: 'media', subnet: '56', size: 22,
    services: ['Radarr:7878', 'Sonarr:8989', 'Readarr:8787', 'Prowlarr:9696', 'Jellyfin:8096', 'qBit:8080', 'Ombi:5000'] },

  // IoT VLAN (subnet 55)
  { id: 'tv', label: 'Samsung TV 98"', ip: '192.168.55.44', type: 'consumer', subnet: '55', size: 16,
    services: ['AirPlay:7000', 'Cast:8008', 'Netflix:9080'] },
  { id: 'pc55', label: 'Windows PC', ip: '192.168.55.191', type: 'consumer', subnet: '55', size: 12,
    services: ['SMB:445'] },
];

const edges = [
  // Everything connects to gateway
  { from: 'gw', to: 'sw', label: '' },
  // Switch connects to key devices
  { from: 'sw', to: 'nas' }, { from: 'sw', to: 'claude' },
  { from: 'sw', to: 'plex' }, { from: 'sw', to: 'plexdl' },
  { from: 'sw', to: 'yvette' },
  // Gateway connects rest
  { from: 'gw', to: 'ha' }, { from: 'gw', to: 'mc' },
  { from: 'gw', to: 'alex' }, { from: 'gw', to: 'desktop' },
  { from: 'gw', to: 'printer' }, { from: 'gw', to: 'echo' },
  { from: 'gw', to: 'switch' }, { from: 'gw', to: 'xbox' },
  { from: 'gw', to: 'gt130' },
  // WiFi AP
  { from: 'gw', to: 'ubap' },
  { from: 'ubap', to: 'iphone' }, { from: 'ubap', to: 'tv' },
  { from: 'ubap', to: 'pc55' },
  // Hyper-V relationships
  { from: 'plex', to: 'ha', dashed: true },
  { from: 'plex', to: 'mc', dashed: true },
  { from: 'plex', to: 'claude', dashed: true },
];

const colors = {
  infra: '#58a6ff', server: '#3fb950', media: '#f0883e',
  iot: '#bc8cff', consumer: '#f778ba',
};

const subnetColors = {
  '53': 'rgba(88, 166, 255, 0.05)',
  '55': 'rgba(188, 140, 255, 0.05)',
  '56': 'rgba(240, 136, 62, 0.05)',
};

// Physics simulation
const W = canvas.width, H = canvas.height;
nodes.forEach((n, i) => {
  // Initial layout by subnet
  const angle = (i / nodes.length) * Math.PI * 2;
  const r = 200 + Math.random() * 100;
  if (n.subnet === '56') {
    n.x = W * 0.75 + (Math.random() - 0.5) * 150;
    n.y = H * 0.5 + (Math.random() - 0.5) * 150;
  } else if (n.subnet === '55') {
    n.x = W * 0.25 + (Math.random() - 0.5) * 100;
    n.y = H * 0.75 + (Math.random() - 0.5) * 100;
  } else {
    n.x = W / 2 + Math.cos(angle) * r;
    n.y = H / 2 + Math.sin(angle) * r;
  }
  if (n.id === 'gw') { n.x = W / 2; n.y = H / 2 - 50; }
  if (n.id === 'sw') { n.x = W / 2 + 60; n.y = H / 2 + 30; }
  n.vx = 0; n.vy = 0;
});

const nodeMap = {};
nodes.forEach(n => nodeMap[n.id] = n);

// Force simulation
function simulate() {
  const repulsion = 8000;
  const attraction = 0.005;
  const damping = 0.85;
  const centerForce = 0.001;

  // Repulsion between all nodes
  for (let i = 0; i < nodes.length; i++) {
    for (let j = i + 1; j < nodes.length; j++) {
      const a = nodes[i], b = nodes[j];
      let dx = b.x - a.x, dy = b.y - a.y;
      let dist = Math.sqrt(dx * dx + dy * dy) || 1;
      let force = repulsion / (dist * dist);
      let fx = (dx / dist) * force, fy = (dy / dist) * force;
      a.vx -= fx; a.vy -= fy;
      b.vx += fx; b.vy += fy;
    }
  }

  // Attraction along edges
  edges.forEach(e => {
    const a = nodeMap[e.from], b = nodeMap[e.to];
    if (!a || !b) return;
    let dx = b.x - a.x, dy = b.y - a.y;
    let dist = Math.sqrt(dx * dx + dy * dy) || 1;
    let force = dist * attraction;
    let fx = (dx / dist) * force, fy = (dy / dist) * force;
    a.vx += fx; a.vy += fy;
    b.vx -= fx; b.vy -= fy;
  });

  // Center gravity
  nodes.forEach(n => {
    n.vx += (W / 2 - n.x) * centerForce;
    n.vy += (H / 2 - n.y) * centerForce;
  });

  // Update positions
  nodes.forEach(n => {
    if (n.dragging) return;
    n.vx *= damping; n.vy *= damping;
    n.x += n.vx; n.y += n.vy;
    n.x = Math.max(40, Math.min(W - 40, n.x));
    n.y = Math.max(40, Math.min(H - 40, n.y));
  });
}

// Rendering
function draw() {
  ctx.fillStyle = '#0d1117';
  ctx.fillRect(0, 0, W, H);

  // Draw subnet backgrounds
  const subnets = {};
  nodes.forEach(n => {
    if (!subnets[n.subnet]) subnets[n.subnet] = [];
    subnets[n.subnet].push(n);
  });

  // Draw edges
  edges.forEach(e => {
    const a = nodeMap[e.from], b = nodeMap[e.to];
    if (!a || !b) return;
    ctx.beginPath();
    ctx.moveTo(a.x, a.y);
    ctx.lineTo(b.x, b.y);
    if (e.dashed) {
      ctx.setLineDash([4, 4]);
      ctx.strokeStyle = 'rgba(139, 148, 158, 0.2)';
    } else {
      ctx.setLineDash([]);
      ctx.strokeStyle = 'rgba(139, 148, 158, 0.3)';
    }
    ctx.lineWidth = 1;
    ctx.stroke();
    ctx.setLineDash([]);
  });

  // Draw nodes
  nodes.forEach(n => {
    const color = colors[n.type] || '#8b949e';

    // Glow
    ctx.beginPath();
    ctx.arc(n.x, n.y, n.size + 6, 0, Math.PI * 2);
    const glow = ctx.createRadialGradient(n.x, n.y, n.size, n.x, n.y, n.size + 8);
    glow.addColorStop(0, color + '30');
    glow.addColorStop(1, 'transparent');
    ctx.fillStyle = glow;
    ctx.fill();

    // Node circle
    ctx.beginPath();
    ctx.arc(n.x, n.y, n.size, 0, Math.PI * 2);
    ctx.fillStyle = color + '20';
    ctx.fill();
    ctx.strokeStyle = color;
    ctx.lineWidth = 2;
    ctx.stroke();

    // Label
    ctx.fillStyle = '#c9d1d9';
    ctx.font = n.size > 16 ? 'bold 12px monospace' : '11px monospace';
    ctx.textAlign = 'center';
    ctx.fillText(n.label, n.x, n.y + n.size + 16);

    // Subnet label
    ctx.fillStyle = '#8b949e';
    ctx.font = '9px monospace';
    ctx.fillText(n.ip, n.x, n.y + n.size + 28);
  });
}

// Interaction
let dragNode = null;
let hoveredNode = null;

canvas.addEventListener('mousedown', e => {
  const mx = e.clientX, my = e.clientY;
  for (const n of nodes) {
    const d = Math.sqrt((mx - n.x) ** 2 + (my - n.y) ** 2);
    if (d < n.size + 5) { dragNode = n; n.dragging = true; break; }
  }
});

canvas.addEventListener('mousemove', e => {
  const mx = e.clientX, my = e.clientY;
  if (dragNode) {
    dragNode.x = mx; dragNode.y = my;
    dragNode.vx = 0; dragNode.vy = 0;
  }

  // Hover detection
  hoveredNode = null;
  for (const n of nodes) {
    const d = Math.sqrt((mx - n.x) ** 2 + (my - n.y) ** 2);
    if (d < n.size + 5) { hoveredNode = n; break; }
  }

  if (hoveredNode) {
    const n = hoveredNode;
    let html = `<div class="name">${n.label}</div>`;
    html += `<div class="ip">${n.ip} (VLAN ${n.subnet})</div>`;
    if (n.services && n.services.length) {
      html += '<div class="services">';
      n.services.forEach(s => { html += `<span class="svc up">${s}</span>`; });
      html += '</div>';
    }
    tooltip.innerHTML = html;
    tooltip.style.display = 'block';
    tooltip.style.left = (mx + 15) + 'px';
    tooltip.style.top = (my + 15) + 'px';
    canvas.style.cursor = 'pointer';
  } else {
    tooltip.style.display = 'none';
    canvas.style.cursor = dragNode ? 'grabbing' : 'default';
  }
});

canvas.addEventListener('mouseup', () => {
  if (dragNode) dragNode.dragging = false;
  dragNode = null;
});

// Animation loop
function loop() {
  canvas.width = window.innerWidth;
  canvas.height = window.innerHeight;
  simulate();
  draw();
  requestAnimationFrame(loop);
}
loop();
</script>
</body>
</html>
